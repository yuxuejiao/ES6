- 以下四个操作会忽略enumerable为false的属性（enumerable属性，称为可枚举性，该属性为false，则意味着不可枚举）
  - for...in循环：只遍历对象自身的和**继承**的可枚举的属性
  - Object.keys()：返回对象自身的可枚举性的属性的键名
  - JSON.stringify()：只串化对象自身的可枚举性的属性
  - Object.assign()：只拷贝对象自身的可枚举性的属性
- 对象属性的遍历：
  - for...in：遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
     可以使用hasOwnProperty()来过滤继承的属性   
     ```
     for(key in obj){
      if(obj.hasOwnProperty(key)){
        
      }
     }
     ```     
     可以遍历数组，但不建议使用
  - Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
  - Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
- Object.is()
  ES5比较两个值是否相等：相等 ==（会自动转换数据类型） 和 全等 ===（NaN不等于它自身，+0等于-0）
  ES6为了解决全等的两个缺陷，推出了Object.is()
  ```
  Object.is('foo', 'foo')
  // true
  Object.is({}, {})
  // false
  Object.is(+0, -0) // false
  Object.is(NaN, NaN) // true
  ```
- Object.assign(target,source,source1,...)：用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。
   - 浅拷贝：如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同步更新。
   - 同名属性替换
  - Object.assign的应用：
   - 为对象添加属性和方法
   - 克隆对象
    ```
      function clone(origin) {
        return Object.assign({}, origin);
      }
    ```
  - 合并对象
    将多个对象合并到某个对象
    ```
    const merge = (target, ...sources) => Object.assign(target, ...sources);
    ```
    如果希望合并后返回一个新对象，可以对一个空对象合并
    ```
    const merge = (...sources) => Object.assign({}, ...sources);
    ```
  - 为属性指定默认值
    ```
    options = Object.assign({}, DEFAULTS, options);
    ```
    DEFAULTS为默认值
-  ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。    
  
